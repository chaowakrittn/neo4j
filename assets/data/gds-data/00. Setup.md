## Initial data
```
// Delete All Nodes and Relationships
MATCH (n)
DETACH DELETE n;

// Drop All Constraints and Indexes
CALL apoc.schema.assert({}, {});

// Create Constraints and Indexes
CREATE RANGE INDEX FOR (n:Movie) ON (n.imdbId);
CREATE RANGE INDEX FOR (n:Movie) ON (n.imdbRating);
CREATE RANGE INDEX FOR (n:Movie) ON (n.released);
CREATE RANGE INDEX FOR (n:Movie) ON (n.tagline);
CREATE RANGE INDEX FOR (n:Movie) ON (n.title);
CREATE RANGE INDEX FOR (n:Movie) ON (n.year);
CREATE RANGE INDEX FOR (n:Person) ON (n.name);
CREATE RANGE INDEX FOR (n:User) ON (n.name);
CREATE CONSTRAINT constraint_3b27b0 FOR (node:User) REQUIRE (node.userId) IS UNIQUE;
CREATE CONSTRAINT constraint_3d5fcb7f FOR (node:Movie) REQUIRE (node.movieId) IS UNIQUE;
CREATE CONSTRAINT constraint_4499eae9 FOR (node:Person) REQUIRE (node.tmdbId) IS UNIQUE;
CREATE CONSTRAINT constraint_737d9c1d FOR (node:Movie) REQUIRE (node.tmdbId) IS UNIQUE;
CREATE CONSTRAINT constraint_f8689281 FOR (node:Genre) REQUIRE (node.name) IS UNIQUE;

// Load the Person nodes
LOAD CSV WITH HEADERS FROM 'file:///export_persons.csv' AS row
WITH row
CALL (row) {
  MERGE (p:Person {tmdbId: toInteger(row.tmdbId)})
  SET p.name = row.name,
      p.imdbId = row.imdbId,
      p.tmdbId = toInteger(row.tmdbId),
      p.poster = row.poster,
      p.born = date(row.born),
      p.died = CASE WHEN row.died <> "" THEN date(row.died) ELSE NULL END,
      p.bornIn = row.bornIn,
      p.bio = row.bio,
      p.url = row.url
  RETURN p
}
WITH p, split(row.labels, ";") AS labels
CALL apoc.create.addLabels(p, labels) YIELD node
RETURN count(*) AS totalImported;

// Load the User nodes
LOAD CSV WITH HEADERS FROM 'file:///export_users.csv' AS row
WITH row
CALL (row) {
  MERGE (u:User {userId: toInteger(row.userId)})
  SET u.name = row.name
  RETURN u
}
WITH u, split(row.labels, ";") AS labels
CALL apoc.create.addLabels(u, labels) YIELD node
RETURN count(*) AS totalImported;

// Load the Movie nodes
LOAD CSV WITH HEADERS FROM 'file:///export_movies.csv' AS row
WITH row
CALL (row) {
  MERGE (x:Movie {movieId: toInteger(row.movieId)})
  SET x.movieId = toInteger(row.movieId),
      x.imdbId = row.imdbId,
      x.title = row.title,
      x.tmdbId = toInteger(row.tmdbId),
      x.year = toInteger(row.year),
      x.countries = [country IN split(row.countries,";") | trim(country)],
      x.languages = [language IN split(row.languages,";") | trim(language)],
      x.plot = row.plot,
      x.imdbRating = toFloat(row.imdbRating),
      x.imdbVotes = toInteger(row.imdbVotes),
      x.released = date(row.released),
      x.runtime = toInteger(row.runtime),
      x.poster = row.poster,
      x.revenue = toInteger(row.revenue),
      x.budget = toInteger(row.budget),
      x.url = row.url
  RETURN x
}
WITH x, split(row.labels, ";") AS labels
CALL apoc.create.addLabels(x, labels) YIELD node
RETURN count(*) AS totalImported;

// Load the Genre nodes
LOAD CSV WITH HEADERS FROM 'file:///export_genres.csv' AS row
WITH row
CALL (row) {
  MERGE (x:Genre {name: row.name})
  RETURN x
}
WITH x, split(row.labels, ";") AS labels
CALL apoc.create.addLabels(x, labels) YIELD node
RETURN count(*) AS totalImported;

// Load the ACTED_IN relationships
LOAD CSV WITH HEADERS FROM 'file:///export_acted_in.csv' AS row
WITH row
CALL (row) {
  MATCH (x1:Person {tmdbId: toInteger(row.person_tmdbId)})
  MATCH (x2:Movie {movieId: toInteger(row.movieId)})
  MERGE (x1)-[x3:ACTED_IN]->(x2)
  SET x3.role = row.role
};

// Load the IN_GENRE relationships
LOAD CSV WITH HEADERS FROM 'file:///export_in_genre.csv' AS row
WITH row
CALL (row) {
  MATCH (x1:Movie {movieId: toInteger(row.movieId)})
  MATCH (x2:Genre {name: row.name})
  MERGE (x1)-[x3:IN_GENRE]->(x2)
};

// Load the DIRECTED relationships
LOAD CSV WITH HEADERS FROM 'file:///export_directed.csv' AS row
WITH row
CALL (row) {
  MATCH (x1:Person {tmdbId: toInteger(row.person_tmdbId)})
  MATCH (x2:Movie {movieId: toInteger(row.movieId)})
  MERGE (x1)-[x3:DIRECTED]->(x2)
  SET x3.role = row.role
};

// Load the RATED relationships
LOAD CSV WITH HEADERS FROM 'file:///export_rated.csv' AS row
WITH row
CALL (row) {
  MATCH (x1:User {userId: toInteger(row.userId)})
  MATCH (x2:Movie {movieId: toInteger(row.movieId)})
  MERGE (x1)-[x3:RATED]->(x2)
  SET x3.rating = toFloat(row.rating),
      x3.timestamp = date(datetime({epochMillis: toInteger(row.timestamp)}))
};
```